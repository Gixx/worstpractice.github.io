/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 8:
/***/ (() => {

/**
 * Feature Toggle component.
 *
 * @param {object} options
 * @returns {*}
 */
const FeatureToggleSwitch = function(options)
{
    /** @instance Utility */
    let utility = globalThis.Components.get('utility')
    /** @instance Logger */
    let logger = new Logger('Feature Toggle Switch', 'Orange');
    /** @type {NodeList} */
    let featureToggleSwitches;
    /** @type {number} */
    let idCounter = 1;

    let featureToggleElements = [];

    /**
     * Initialize the component handler.
     */
    const initialize = function(reScan = false)
    {
        !reScan && logger.seekComponentElements();

        featureToggleSwitches = document.querySelectorAll('.FeatureToggle[data-feature]');

        if (featureToggleSwitches.length === 0) {
            logger.componentElementsNotFound();
            return;
        }

        featureToggleSwitches.forEach(function (HTMLElement) {
            if (!HTMLElement.hasAttribute('id')) {
                HTMLElement.setAttribute('id', 'FeatureToggle-' + (idCounter++));
            }

            const featureName = HTMLElement.dataset.feature;
            const featureValue = 'value' in HTMLElement.dataset ? HTMLElement.dataset.value : 'off';
            const state = featureValue !== 'off';
            const toggleOptions = (typeof options[featureName] !== 'undefined')
                ? options[featureName]
                : {state: state, label: 'Toggle feature "'+featureName+'" On or Off', storageKey: 'feature_'+featureName};

            featureToggleElements.push(new FeatureToggleSwitchElement(HTMLElement, featureName, toggleOptions));
        });

        !reScan && utility.triggerEvent(document, 'Component.FeatureToggleSwitch.Ready', null, 1);
    };

    logger.componentLoaded();
    initialize();

    return {
        reScan: function() {
            initialize();
        },

        /**
         * Returns the collection of feature toggle elements
         *
         * @returns {*[]}
         */
        getElements: function () {
            return featureToggleElements;
        },

        /**
         * Get all FeatureToggle elements by name.
         *
         * @param {String} featureToggleName The non-unique name of the FeatureToggle element.
         * @returns {[]}
         */
        getElementsByName : function(featureToggleName) {
            const components = [];

            featureToggleElements.forEach(function (element) {
                if (element.getName() === featureToggleName) {
                    components.push(element.component);
                }

            });

            return components;
        },

        /**
         * Toggle FeatureToggle element(s) by the given name.
         *
         * @param {String} featureToggleName The non-unique name of the FeatureToggle element.
         * @return {Array}
         */
        toggleSwitch : function(featureToggleName) {
            featureToggleElements.forEach(function (element) {
                if (element.getName() === featureToggleName) {
                    if (element.getState() === 'on') {
                        element.off();
                    } else {
                        element.on();
                    }
                }
            });
        },

        /**
         * Toggle on/off all FeatureToggle elements.
         *
         * @param {String} newState The new status: 'on' or 'off'.
         */
        toggleAll : function (newState = 'on') {
            if (['on', 'off'].indexOf(newState) === -1) {
                newState = 'on';
            }

            featureToggleElements.forEach(function (element) {
                if (newState === 'on') {
                    element.component.on();
                } else {
                    element.component.off();
                }
            });
        }
    };
};

window['FeatureToggleSwitch'] = FeatureToggleSwitch;

/***/ }),

/***/ 73:
/***/ (() => {

/**
 * Adds lazy-load behaviour to an image element.
 *
 * @param {HTMLImageElement|Node} HTMLElement
 * @returns {*}
 */
const LazyLoadImageElement = function (HTMLElement)
{
    /** @instance Logger */
    let logger = new Logger('Lazy Load Image Element', 'SkyBlue');

    logger.componentElementInitSuccess(HTMLElement.id)

    return {
        /**
         * Returns the element ID.
         *
         * @returns {string}
         */
        getId: function () {
            return HTMLElement.id;
        },

        /**
         * Returns the element name.
         *
         * @returns {string}
         */
        getName: function() {
            return HTMLElement.id;
        },

        /**
         * Returns the HTML element
         *
         * @returns {HTMLDivElement|Node}
         */
        getHTMLElement: function () {
            return HTMLElement;
        },

        /**
         * Loads the actual image when it gets into view
         */
        loadImage: function () {
            if (!HTMLElement.hasAttribute('data-src')) {
                return;
            }
            const imageSource = HTMLElement.dataset.src;
            const preload  = new Image();

            preload.addEventListener('error', function (event) {
                event.preventDefault();
                logger.actionFailed('An image resource is not found', imageSource);
            });

            preload.addEventListener('load', function () {
                HTMLElement.src = imageSource;
                HTMLElement.removeAttribute('data-src');
                logger.actionSuccess('A Lazy Load Image element loaded', HTMLElement.getAttribute('id'));
            });

            preload.src = imageSource;
        }
    }
};

window['LazyLoadImageElement'] = LazyLoadImageElement;


/***/ }),

/***/ 84:
/***/ (() => {

/**
 * SmoothScroll component.
 *
 * @returns {*}
 */
const SmoothScroll = function ()
{
    /** @instance Utility */
    let utility = globalThis.Components.get('utility')
    /** @instance Logger */
    let logger = new Logger('Smooth Scroll', 'SteelBlue');

    if (!utility instanceof Utility) {
        throw new ReferenceError('This component requires the Utility component to be loaded.');
    }

    /**
     * Return the actual scroll position in pixels.
     *
     * @return {number}
     */
    const getScrollPosition = function () {
        return window.scrollY;
    };

    /**
     * Return the client height in pixels.
     *
     * @return {number}
     */
    const getClientHeight = function () {
        return document.documentElement.clientHeight;
    }

    /**
     * Return the document height in pixels.
     *
     * @return {number}
     */
    const getDocumentHeight = function () {
        return document.body.offsetHeight;
    }

    /**
     * Return the maximum scroll position available in pixels.
     * @return {number}
     */
    const getMaxScrollTop = function () {
        return getDocumentHeight() - getClientHeight();
    }

    /**
     * Return the actual scroll position of an element in the document.
     *
     * @param {String} elementId
     * @return {number}
     */
    const getElementPosition = function (elementId) {
        const element = document.getElementById(elementId);

        if (!element) {
            return 0;
        }

        const boundingBox = element.getBoundingClientRect();
        return boundingBox.top;
    }

    /**
     * Takes small steps until reach the target.
     *
     * @param {Number} from
     * @param {Number} to
     */
    const smoothScroll = function (from, to) {
        const stepBy = 0.2;
        const snapDistance = 1;
        const speed = 30;
        const diff = to - from;

        if (Math.abs(diff) <= snapDistance) {
            scrollTo(0.0, to);
            logger.actionSuccess('Scroll end', to+'px');
            return;
        }

        const nextPosition = (from * (1.0 - stepBy)) + (to * stepBy);
        scrollTo(0.0, Math.round(nextPosition));

        setTimeout(smoothScroll, speed, nextPosition, to);
    }

    /**
     * Initializes the component and collects the elements.
     */
    const initialize = function ()
    {
        utility.triggerEvent(document, 'Component.SmoothScroll.Ready', null, 1);
    };

    logger.componentLoaded();

    initialize();

    return {
        /**
         * Return the actual scroll position in pixels.
         *
         * @return {number}
         */
        getScrollPosition: function() {
            return getScrollPosition();
        },

        /**
         * Return the actual scroll position of an element in the document.
         *
         * @param {String} elementId
         * @return {number}
         */
        getElementPositionById: function(elementId) {
            return getElementPosition(elementId);
        },

        /**
         * Scroll to an element specified by its ID.
         *
         * @param {String} elementId The ID of the HTML element to scroll
         * @param {Number} gap       The gap to keep on top in pixels
         */
        scrollToElementById: function(elementId, gap) {
            const element = document.getElementById(elementId);

            if (!element) {
                return false;
            }

            const targetPosition = Math.min((getScrollPosition() + getElementPosition(elementId) - gap), getMaxScrollTop());

            logger.actionTriggered('Start scroll', getScrollPosition()+'px')
            smoothScroll(getScrollPosition(), targetPosition);
        }
    };
};

window['SmoothScroll'] = SmoothScroll;

/***/ }),

/***/ 192:
/***/ (() => {

/**
 * A Collapsible Element.
 *
 * @param {HTMLDivElement|Node} HTMLElement
 * @return {*}
 */
const CollapsibleElement = function (HTMLElement)
{
    /** @instance Logger */
    let logger = new Logger('CollapsibleElement', 'LightYellow');

    if (!HTMLElement.nextElementSibling?.classList.contains('Collapsible__content')) {
        return false;
    }

    HTMLElement.addEventListener('click', function(event) {
        toggleCollapsible(event.target);
    });

    const toggleCollapsible = function (HTMLElement) {
        HTMLElement.classList.toggle('active');

        let isActive  = HTMLElement.classList.contains('active');

        logger.actionTriggered('Element ' + (isActive ? 'opened' : 'closed'), HTMLElement.id)

        const content = HTMLElement.nextElementSibling;

        if (content.style.maxHeight) {
            content.style.maxHeight = null;
        } else {
            content.style.maxHeight = content.scrollHeight + "px";
        }
    }

    logger.componentElementInitSuccess(HTMLElement.getAttribute('id'));

    return {
        /**
         * Returns the element ID.
         *
         * @returns {string}
         */
        getId: function () {
            return HTMLElement.id;
        },

        /**
         * Returns the element name.
         *
         * @returns {string}
         */
        getName: function() {
            return HTMLElement.id;
        },

        /**
         * Returns the HTML element
         *
         * @returns {HTMLDivElement|Node}
         */
        getHTMLElement: function () {
            return HTMLElement;
        },

        /**
         * Toggle this Collapsible Element.
         */
        toggle: function () {
            toggleCollapsible(HTMLElement);
        }
    }
}

window['CollapsibleElement'] = CollapsibleElement

/***/ }),

/***/ 254:
/***/ (() => {

/**
 * Collapsible component.
 *
 * @returns {*}
 */
const Collapsible = function ()
{
    /** @instance Utility */
    let utility = globalThis.Components.get('utility')
    /** @instance Logger */
    let logger = new Logger('Collapsible', 'PaleGoldenRod');
    /** @type {NodeList} */
    let collapsibleButtons;
    /** @type {number} */
    let idCounter = 1;

    let collapsibleElements = [];

    if (!utility instanceof Utility) {
        throw new ReferenceError('This component requires the Utility component to be loaded.');
    }

    /**
     * Initializes the component and collects the elements.
     */
    const initialize = function ()
    {
        logger.seekComponentElements();

        collapsibleButtons = document.querySelectorAll('.Collapsible button');

        if (collapsibleButtons.length === 0) {
            logger.componentElementsNotFound();
            return;
        }

        collapsibleButtons.forEach(function (HTMLElement) {
            if (!HTMLElement.hasAttribute('id')) {
                HTMLElement.setAttribute('id', 'Collapsible-' + (idCounter++));
            }

            collapsibleElements.push(new CollapsibleElement(HTMLElement));
        });

        utility.triggerEvent(document, 'Component.Collapsible.Ready', null, 1);
    };

    logger.componentLoaded();

    initialize();

    return {

        /**
         * Return the collection of collapsible elements
         *
         * @returns {*[]}
         */
        getElements: function() {
            return collapsibleElements;
        },

        /**
         * Toggle a collapsible element.
         *
         * @param {String} elementId
         */
        toggleCollapsibleById: function(elementId) {
            collapsibleElements.forEach(function (element) {
                if (element.getId() === elementId) {
                    element.toggle();
                }
            });
        }
    };
};

window['Collapsible'] = Collapsible;

/***/ }),

/***/ 283:
/***/ (() => {

/**
 * BarChart component.
 *
 * @returns {*}
 */
const BarChart = function ()
{
    /** @instance Utility */
    let utility = globalThis.Components.get('utility');
    /** @instance Logger */
    let logger = new Logger('Bar Chart', 'MediumPurple');
    /** @type {NodeList} */
    let chartWrappers;
    /** @type {number} */
    let idCounter = 1;

    const barChartElements = [];

    /** @type {object} */
    const chartStyles = utility.readStylesheetsByClassName('BarChart');

    /**
     * Initializes the component and collects the elements.
     */
    const initialize = function ()
    {
        logger.seekComponentElements();

        chartWrappers = document.querySelectorAll('.BarChart .grid');

        if (chartWrappers.length ===0) {
            logger.componentElementsNotFound();
            return;
        }

        chartWrappers.forEach(function (HTMLElement) {
            if (!HTMLElement.hasAttribute('id')) {
                HTMLElement.setAttribute('id', 'BarChart-' + (idCounter++));
            }

            barChartElements.push(new BarChartElement(HTMLElement, chartStyles));
        });

        utility.triggerEvent(document, 'Component.BarChart.Ready', null,  1);
    };

    logger.componentLoaded();

    initialize();

    return {
        /**
         * Returns the collection of chart-elements
         *
         * @returns {*[]}
         */
        getElements: function() {
            return barChartElements;
        }
    };
};

window['BarChart'] = BarChart;

/***/ }),

/***/ 322:
/***/ (() => {

/**
 * Component Repository
 *
 * @returns {*}
 */
const ComponentRepository = function()
{
    const components = {};

    console.error('fdfsf')

    return {
        register: function(name, component) {
            components[name] = component;
        },

        get: function(name) {
            return components[name];
        },

        getAll: function() {
            return components;
        }
    };
};

window['ComponentRepository'] = ComponentRepository

/***/ }),

/***/ 326:
/***/ (() => {

/**
 * A Dialog element.
 *
 * @param {HTMLDivElement|Node} HTMLElement
 * @returns {*}
 */
const DialogWindowElement = function (HTMLElement)
{
    /** @instance Utility */
    let utility = globalThis.Components.get('utility')
    /** @instance Logger */
    let logger = new Logger('Dialog Window Element', 'Teal');

    const okButton = HTMLElement.querySelector('.d-buttons__ok');
    const saveButton = HTMLElement.querySelector('.d-buttons__save');
    const applyButton = HTMLElement.querySelector('.d-buttons__apply');
    const deleteButton = HTMLElement.querySelector('.d-buttons__delete');
    const cancelButton = HTMLElement.querySelector('.d-buttons__cancel');
    const closeButton = HTMLElement.querySelector('.d-buttons__close');

    const introTabSwitchButton = HTMLElement.querySelector('.d-buttons__showIntro');
    const settingsTabSwitchButton = HTMLElement.querySelector('.d-buttons__showSettings');

    const contentIntro = HTMLElement.querySelector('.d-tab.-intro');
    const contentSettings = HTMLElement.querySelector('.d-tab.-settings');

    const openDialog = function() {
        HTMLElement.style.display = 'block';
        logger.actionTriggered('"'+HTMLElement.id+'" Dialog window is opened', HTMLElement.id);
    };

    const dialogName = HTMLElement.dataset.name;

    /**
     * Closes the modal window
     */
    const closeDialog = function () {
        HTMLElement.style.display = 'none';
        logger.actionTriggered('"'+HTMLElement.id+'" Dialog window is closed', HTMLElement.id);
    };

    /**
     * Button click events
     */
    okButton && okButton.addEventListener('click', function () {
        utility.triggerEvent(HTMLElement, 'Component.Dialog.Action.OK');
        closeDialog();
    });

    saveButton && saveButton.addEventListener('click', function () {
        utility.triggerEvent(HTMLElement, 'Component.Dialog.Action.Save');
        closeDialog();
    });

    applyButton && applyButton.addEventListener('click', function () {
        utility.triggerEvent(HTMLElement, 'Component.Dialog.Action.Apply');
        closeDialog();
    });

    deleteButton && deleteButton.addEventListener('click', function () {
        utility.triggerEvent(HTMLElement, 'Component.Dialog.Action.Delete');
        closeDialog();
    });

    cancelButton && cancelButton.addEventListener('click', function () {
        utility.triggerEvent(HTMLElement, 'Component.Dialog.Action.Cancel');
        closeDialog();
    });

    closeButton && closeButton.addEventListener('click', function () {
        utility.triggerEvent(HTMLElement, 'Component.Dialog.Action.Close');
        closeDialog();
    });

    settingsTabSwitchButton && settingsTabSwitchButton.addEventListener('click', function () {
        contentIntro.classList.remove('-active');
        contentSettings.classList.add('-active');
    });

    introTabSwitchButton && introTabSwitchButton.addEventListener('click', function () {
        contentIntro.classList.add('-active');
        contentSettings.classList.remove('-active');
    });

    logger.componentElementInitSuccess(HTMLElement.id);

    return {
        /**
         * Returns the element ID.
         *
         * @returns {string}
         */
        getId: function () {
            return HTMLElement.id;
        },

        /**
         * Returns the element name.
         *
         * @returns {string}
         */
        getName: function() {
            return dialogName;
        },

        /**
         * Returns the HTML element
         *
         * @returns {HTMLDivElement|Node}
         */
        getHTMLElement: function () {
            return HTMLElement;
        },

        /**
         * Opens the modal window.
         */
        open: function() {
            openDialog();
        },

        /**
         * Closes the modal window
         */
        close: function () {
            closeDialog();
        }
    }
};

window['DialogWindowElement'] = DialogWindowElement;

/***/ }),

/***/ 491:
/***/ (() => {


/**
 * Logger component.
 *
 * @param {string} componentName
 * @param {string} colorId
 * @returns {*}
 */
const Logger = function (componentName, colorId)
{
    /** @type {string} */
    const consoleLabelTextColorId = '#599bd6';
    const verbose = false;

    const loggerInitialized = function () {
        verbose && console.info(
            '%c[Logger]%c ✔%c A new instance is created for %o %ccomponent.',
            'background:Indigo;color:white;font-weight:bold;',
            'color:green; font-weight:bold;',
            'color:'+consoleLabelTextColorId+'; font-weight:bold;',
            componentName,
            'color:'+consoleLabelTextColorId+'; font-weight:bold;',
        );
    }

    loggerInitialized();

    return {
        warn: function (message, exception = null) {
            console.warn(message, exception);
        },

        error: function (message, exception = null) {
            console.error(message, exception);
        },

        actionTriggered: function (message, subject) {
            console.info(
                '%c['+componentName+']%c ⚡%c '+message+': %o',
                'background:'+colorId+';color:black;font-weight:bold;',
                'color:orange;font-weight:bold',
                'color:'+consoleLabelTextColorId+';font-style:italic',
                subject
            );
        },

        actionSuccess: function (message, data = '') {
            console.info(
                '%c['+componentName+']%c ✔%c '+message+'. %o',
                'background:'+colorId+';color:black;font-weight:bold;',
                'color:green;font-weight:bold',
                'color:'+consoleLabelTextColorId+';font-style:italic',
                data
            );
        },

        actionFailed: function (message, error = 'null') {
            console.info(
                '%c['+componentName+']%c ✖%c '+message+': %o',
                'background:'+colorId+';color:black;font-weight:bold;',
                'color:red',
                'color:'+consoleLabelTextColorId+';font-style:italic',
                error
            );
        },

        componentLoaded: function () {
            console.info(
                '%c['+componentName+']%c ✔%c The '+componentName+' component loaded.',
                'background:'+colorId+';color:black;font-weight:bold;',
                'color:green; font-weight:bold;',
                'color:'+consoleLabelTextColorId+'; font-weight:bold;'
            );
        },

        seekComponentElements: function () {
            console.info(
                '%c['+componentName+']%c ೱ%c looking for '+componentName+' elements.',
                'background:'+colorId+';color:black;font-weight:bold;',
                'color:lightBlue; font-weight:bold;',
                'color:'+consoleLabelTextColorId+';font-style:italic'
            );
        },

        componentElementsNotFound: function () {
            console.info(
                '%c['+componentName+']%c ✖%c No component elements found for '+componentName+'.',
                'background:'+colorId+';color:black;font-weight:bold;',
                'color:red; font-weight:bold;',
                'color:'+consoleLabelTextColorId+';font-style:italic'
            );
        },

        componentElementInitSuccess: function (elementId) {
            console.info(
                '%c['+componentName+']%c ✚%c a '+componentName+' element initialized %o',
                'background:'+colorId+';color:black;font-weight:bold;',
                'color:green; font-weight:bold;',
                'color:'+consoleLabelTextColorId+';font-style:italic',
                '#'+elementId
            );
        }
    };
};

window['Logger'] = Logger;

/***/ }),

/***/ 559:
/***/ (() => {


/**
 * Http component.
 *
 * @returns {*}
 */
const Http = function ()
{
    /** @instance Utility */
    let utility = globalThis.Components.get('utility')
    /** @instance Logger */
    let logger = new Logger('Http', 'GreenYellow');

    if (!utility instanceof Utility) {
        throw new ReferenceError('This component requires the Utility component to be loaded.');
    }

    /**
     * Initializes the component and collects the elements.
     */
    const initialize = function ()
    {
        utility.triggerEvent(document, 'Component.Http.Ready', null, 1);
    };

    logger.componentLoaded();

    initialize();

    /**
     * Makes an XmlHttpRequest.
     *
     * @param {string} url
     * @param {string} method
     * @param {boolean} async
     * @param {string} enctype
     * @param {FormData|object} data
     * @param {null|function} successCallback
     * @param {null|function} failureCallback
     * @returns {XMLHttpRequest}
     */
    const doXmlHttpRequest = function(url, method, async, enctype, data, successCallback, failureCallback)
    {
        const rnd = new Date().getTime();
        url = url + (url.lastIndexOf('?') === -1 ? '?' : '&') + 'timestamp=' + rnd;

        const xhr = new XMLHttpRequest();
        xhr.open(method, url, async);

        xhr.onreadystatechange = function () {
            if (xhr.readyState === XMLHttpRequest.DONE) {
                try {
                    if (xhr.status === 200) {
                        successCallback(xhr.responseText);
                    } else {
                        failureCallback(xhr.responseText);
                    }
                } catch (exp) {
                    logger.warn('JSON parse error. Continue', exp);
                }
            }
        };

        // if NOT multipart/form-data, turn the FromData into object
        if (data instanceof FormData && enctype !== 'multipart/form-data') {
            data = utility.formDataToObject(data);
        }

        // if mulitpart/form-data, turn the data into FormData
        if (!data instanceof FormData && enctype === 'multipart/form-data') {
            data = utility.objectToFormData(data);
        }

        switch (enctype) {
            case 'application/json':
                data = JSON.stringify(data);
                xhr.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
                break;

            case 'application/x-www-form-urlencoded':
                data = Object.keys(data).map(function (key) {
                    return key + '=' + data[key]
                }).join('&');
                xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
                break;

            case 'multipart/form-data':
                xhr.setRequestHeader('Content-Type', 'multipart/form-data');
                break;
        }

        xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
        xhr.send(data);

        return xhr;
    };

    /**
     * Fetches a URL
     *
     * @param {string} url
     * @param {string} method
     * @param {boolean} async
     * @param {string} enctype
     * @param {FormData|object} data
     * @param {null|function} successCallback
     * @param {null|function} failureCallback
     * @return Promise
     */
    const doFetch = function(url, method, async, enctype, data, successCallback, failureCallback)
    {
        switch (enctype) {
            case 'application/json':
                if (data instanceof FormData) {
                    data = utility.formDataToObject(data);
                }

                data = JSON.stringify(data);
                break;

            case 'application/x-www-form-urlencoded':
                if (data instanceof FormData) {
                    data = utility.formDataToObject(data);
                }

                data = Object.keys(data).map(function (key) {
                    return key + '=' + data[key]
                }).join('&');
                break;

            case 'multipart/form-data':
                if (!data instanceof FormData) {
                    data = utility.objectToFormData(data);
                }
                break;
        }

        const request = {
            method: method,
            headers: {
                'Content-Type': enctype,
                'X-Requested-With': 'XMLHttpRequest'
            }
        };

        if (method !== 'GET' && method !== 'HEAD') {
            request.body = data;
        }

        logger.actionTriggered('Fetching URL', url);

        return fetch(url, request)
            .then(function (response) {
                if (response.ok) {
                    logger.actionSuccess('URL fetch successful', url)
                    return successCallback(response);
                } else {
                    return failureCallback(response);
                }
            })
            .catch(function (){
                logger.actionFailed('URL fetch failed', url)
            });
    };

    return {
        /**
         * Makes an XmlHttpRequest.
         *
         * @param {string} url
         * @param {string} method
         * @param {boolean} async
         * @param {string} enctype
         * @param {FormData|object} data
         * @param {null|function} successCallback
         * @param {null|function} failureCallback
         * @returns {XMLHttpRequest}
         */
        ajax : function (url = '/', method = 'POST', async = true, enctype = 'application/json', data = {}, successCallback = null, failureCallback = null) {
            if (typeof successCallback !== 'function') {
                successCallback = function (data) {};
            }

            if (typeof failureCallback !== 'function') {
                failureCallback =  function (data) {};
            }

            return doXmlHttpRequest(url, method, async, enctype, data, successCallback, failureCallback);
        },

        /**
         * Fetches a URL
         *
         * @param {string} url
         * @param {string} method
         * @param {boolean} async
         * @param {string} enctype
         * @param {FormData|object} data
         * @param {null|function} successCallback
         * @param {null|function} failureCallback
         * @return Promise
         */
        fetch: function (url = '/', method = 'POST', async = true, enctype = 'application/json', data = {}, successCallback = null, failureCallback = null) {
            if (typeof successCallback !== 'function') {
                successCallback = function (data) {
                    return new Promise((resolve, reject) => {
                        resolve(data);
                    });
                };
            }

            if (typeof failureCallback !== 'function') {
                failureCallback =  function (data) {
                    return new Promise((resolve, reject) => {
                        reject(data);
                    });
                };
            }

            return doFetch(url, method, async, enctype, data, successCallback, failureCallback);
        }
    };
};

window['Http'] = Http;

/***/ }),

/***/ 653:
/***/ (() => {

/**
 * Cookie Storage component.
 *
 * @returns {*}
 */
const CookieStorage = function ()
{
    const MAX_COOKIE_EXPIRATION_DAYS = 7;

    /** @instance Utility */
    let utility = globalThis.Components.get('utility')
    /** @instance Logger */
    let logger = new Logger('Cookie Storage', 'SpringGreen');

    if (!utility instanceof Utility) {
        throw new ReferenceError('This component requires the Utility component to be loaded.');
    }

    /**
     * Initialize component
     */
    const initialize = function()
    {
        utility.triggerEvent(document, 'Component.Cookie.Ready', null, 1);
    };

    /**
     * Set a cookie.
     *
     * @param {string} cookieName  The name of the cookie
     * @param {string} cookieValue The value of the cookie
     * @param {number} expirationDays Expiration days
     * @param {boolean} standardLog Whether to log the standard info or not
     */
    const setCookie = function (cookieName, cookieValue, expirationDays, standardLog = true)
    {
        const date = new Date();
        date.setTime(date.getTime() + (expirationDays * 24 * 60 * 60 * 1000));
        const expires = "expires="+ date.toUTCString();

        standardLog && logger.actionTriggered('Setting Cookie', cookieValue);
        document.cookie = cookieName + '=' + cookieValue + ';' + expires + ';path=/;SameSite=Lax' + (location.protocol === 'https:' ? ';secure' : '');
    };

    /**
     * Retrieve a cookie value.
     *
     * @param {string} cookieName The name of the cookie
     * @returns {string}
     */
    const getCookie = function (cookieName)
    {
        const name = cookieName + "=";
        const decodedCookie = decodeURIComponent(document.cookie);
        const cookieArray = decodedCookie.split(';');
        let cookie, i, num;

        for (i = 0, num = cookieArray.length; i < num; i++) {
            cookie = cookieArray[i];
            while (cookie.charAt(0) === ' ') {
                cookie = cookie.substring(1);
            }
            if (cookie.indexOf(name) === 0) {
                return cookie.substring(name.length, cookie.length);
            }
        }

        return '';
    };

    /**
     * Renew a cookie if exists.
     *
     * @param {string} cookieName The name of the cookie
     * @param {number} expirationDays Expiration days of the cookie
     */
    const renewCookie = function(cookieName, expirationDays)
    {
        const cookieValue = getCookie(cookieName);

        if (cookieValue !== '') {
            logger.actionTriggered('Renew Cookie', cookieName);
            setCookie(cookieName, cookieValue, expirationDays, false);
        }
    };

    /**
     * Delete a cookie if exists.
     *
     * @param {string} cookieName The name of the cookie
     */
    const deleteCookie = function(cookieName)
    {
        if (getCookie(cookieName) !== '') {
            logger.actionTriggered('Delete Cookie', cookieName);
            setCookie(cookieName, '', -1);
        }
    };

    logger.componentLoaded();

    initialize();

    return {
        /**
         * Set a cookie.
         *
         * @param {string} key  The name of the cookie
         * @param {string} value The value of the cookie
         * @param {boolean} session The data should be deleted when the browser session ends.
         */
        set: function (key, value, session = false) {
            const expirationDays = session ? 0 : MAX_COOKIE_EXPIRATION_DAYS;

            setCookie(key, value, expirationDays);
        },

        /**
         * Retrieve a cookie value.
         *
         * @param {string} key The name of the cookie
         * @returns {string}
         */
        get: function (key) {
            return getCookie(key);
        },

        /**
         * Renew a cookie if exists.
         *
         * @param {string} key The name of the cookie
         * @param {boolean} session The data should be deleted when the browser session ends.
         */
        renew: function(key, session = false) {
            const expirationDays = session ? 0 : MAX_COOKIE_EXPIRATION_DAYS;

            renewCookie(key, expirationDays);
        },

        /**
         * Delete a cookie if exists.
         *
         * @param {string} key The name of the cookie
         */
        delete: function(key) {
            deleteCookie(key);
        },
    }
};

window['CookieStorage'] = CookieStorage;

/***/ }),

/***/ 756:
/***/ (() => {

/**
 * DialogWindow component.
 *
 * @returns {*}
 */
const DialogWindow = function ()
{
    /** @instance Utility */
    let utility = globalThis.Components.get('utility')
    /** @instance Logger */
    let logger = new Logger('Dialog Window', 'Turquoise');

    let dialogWindowElements = [];
    /** @type {number} */
    let idCounter = 1;

    if (!utility instanceof Utility) {
        throw new ReferenceError('This component requires the Utility component to be loaded.');
    }

    /**
     * Initializes the component and collects the elements.
     */
    const initialize = function ()
    {
        logger.seekComponentElements();

        const dialogHTMLElements = document.querySelectorAll('.DialogWindow');

        if(dialogHTMLElements.length === 0) {
            logger.componentElementsNotFound();
            return;
        }

        dialogHTMLElements.forEach(function (HTMLElement) {
            if (!HTMLElement.hasAttribute('id')) {
                HTMLElement.setAttribute('id', 'DialogWindow-' + (idCounter++));
            }

            dialogWindowElements.push(new DialogWindowElement(HTMLElement));
        });

        utility.triggerEvent(document, 'Component.DialogWindow.Ready', null, 1);
    };

    logger.componentLoaded();
    initialize();

    return {
        /**
         * Returns the collection of dialog elements
         *
         * @returns {*[]}
         */
        getElements: function () {
            return dialogWindowElements;
        },

        /**
         *
         * @param {String} dialogName
         */
        getDialogWindowElementByName: function(dialogName) {
            dialogWindowElements.forEach(function (element) {
                if (element.getName() === dialogName) {
                    return element;
                }
            });

            return null;
        }
    };
};

window['DialogWindow'] = DialogWindow;



/***/ }),

/***/ 768:
/***/ (() => {

/**
 * Data Storage component.
 *
 * @returns {*}
 */
const LocalStorage = function ()
{
    /** @instance Utility */
    let utility = globalThis.Components.get('utility')
    /** @instance Logger */
    let logger = new Logger('Data Storage', 'SpringGreen');
    /** @type {object} */
    const storage = {};

    if (!utility instanceof Utility) {
        throw new ReferenceError('This component requires the Utility component to be loaded.');
    }

    if (typeof(Storage) === 'undefined') {
        throw new ReferenceError('Your browser does not support the local/session storage feature.');
    }

    /**
     * Initialize component
     */
    const initialize = function()
    {
        initStorageKeys(localStorage);
        initStorageKeys(sessionStorage);

        utility.triggerEvent(document, 'Component.DataStorage.Ready', null, 1);
    };

    /**
     * Fills up the registry.
     *
     * @param storageEngine
     */
    const initStorageKeys = function(storageEngine)
    {
        const storageKeys = Object.keys(storageEngine);
        let i = storageKeys.length;

        while (i--) {
            storage[storageKeys[i]] = storageEngine;
        }
    };

    /**
     * Set data.
     *
     * @param {string} key      The name of the key
     * @param {string} value    The value
     * @param {boolean} session Mark it as session data (for the logging only)
     */
    const setData = function (key, value, session = false)
    {
        //logger.actionTriggered('Setting data into dataStorage', key + (session ? ' (session)' : '') + ': "'+value+'"');
        typeof storage[key] !== 'undefined' && storage[key].setItem(key, value);
    };

    /**
     * Retrieve data by key.
     *
     * @param {string} key The name of the key
     * @returns {string}
     */
    const getDataByKey = function (key)
    {
        return typeof storage[key] !== 'undefined'
            ? storage[key].getItem(key)
            : '';
    };

    /**
     * Delete data by key.
     *
     * @param {string} key The name of the key
     */
    const deleteDataByKey = function(key)
    {
        typeof storage[key] !== 'undefined' && storage[key].removeItem(key);
    };

    logger.componentLoaded();
    initialize();

    return {
        /**
         * Set data.
         *
         * @param {string} key   The name of the key
         * @param {string} value The value
         * @param {boolean} session The data should be deleted when the browser session ends.
         */
        set: function (key, value, session = false) {
            // To avoid to leave mess in local storage when setting an existing key to session storage, first we delete.
            deleteDataByKey(key);

            storage[key] = session ? sessionStorage : localStorage;

            setData(key, value, session);
        },

        /**
         * Retrieve data by key.
         *
         * @param {string} key The name of the key
         * @returns {string}
         */
        get: function (key) {
            return getDataByKey(key);
        },

        /**
         * Renew a data if exists.
         * No real use. Its only purpose is to be compatible with the CookieStorage.
         *
         * @param {string} key The name of the key
         * @param {boolean} session The data should be deleted when the browser session ends.
         */
        renew: function(key, session = false) {
            const value = getDataByKey(key);

            if (value !== '') {
                this.set(key, value, session);
            }
        },

        /**
         * Delete data by key.
         *
         * @param {string} key The name of the key
         */
        delete: function(key) {
            deleteDataByKey(key);
        },
    }
};

window['LocalStorage'] = LocalStorage;

/***/ }),

/***/ 823:
/***/ (() => {

/**
 * Utility component.
 *
 * @returns {*}
 */
const Utility = function ()
{
    /** @instance Logger */
    let logger = new Logger('Utility', 'Salmon');

    /**
     * Initialize component
     */
    const initialize = function()
    {
        setTimeout(function() { triggerEvent(document, 'Component.Utility.Ready', null) }, 1);
    };

    /**
     * Triggers an event on an element.
     *
     * @param {*}       element
     * @param {string}  eventName
     * @param {*}       [customData]
     */
    const triggerEvent = function (element, eventName, customData)
    {
        let event;

        if (customData !== null) {
            event = new CustomEvent(eventName, {'detail': customData})
        } else {
            event = new Event(eventName);
        }

        logger.actionTriggered('Triggering event', eventName);

        element.dispatchEvent(event);
    };

    logger.componentLoaded();

    initialize();

    return {
        /**
         * Converts a form data to object
         *
         * @param {FormData} formData
         * @return {Object}
         */
        formDataToObject: function (formData)
        {
            const object = {};

            formData.forEach(function (value, key) {
                object[key] = value;
            });

            return object;
        },

        /**
         * Converts an object to form data
         *
         * @param {Object} object
         * @return {FormData}
         */
        objectToFormData: function (object)
        {
            const formData = new FormData();

            for (let attribute in object) {
                if (object.hasOwnProperty(attribute)) {
                    formData.append(attribute, object[attribute]);
                }
            }

            return formData
        },

        /**
         * Triggers an event on an element.
         *
         * @param {*}      element
         * @param {string} eventName
         * @param {*}      [customData]
         * @param {number} delay
         */
        triggerEvent : function (element, eventName, customData = null, delay = 0) {
            if (delay === 0) {
                triggerEvent(element, eventName, customData);
            } else {
                setTimeout(function() { triggerEvent(element, eventName, customData) }, delay);
            }
        },

        /**
         * Returns the event element path.
         *
         * @param {Event} event
         * @return {Array}
         */
        getEventPath: function (event) {
            let path = (event.composedPath && event.composedPath()) || event.path,
                target = event.target;

            if (typeof path !== 'undefined') {
                // Safari doesn't include Window, and it should.
                path = (path.indexOf(window) < 0) ? path.concat([window]) : path;
                return path;
            }

            if (target === window) {
                return [window];
            }

            function getParents(node, memo)
            {
                memo = memo || [];
                const parentNode = node.parentNode;

                if (!parentNode) {
                    return memo;
                } else {
                    return getParents(parentNode, memo.concat([parentNode]));
                }
            }

            return [target]
                .concat(getParents(target))
                .concat([window]);
        },

        /**
         * Tries to figure out the operating system
         *
         * @returns {string}
         */
        getDeviceOs: function () {
            let operatingSystem = 'Unknown';
            const patterns = ['Win', 'Mac', 'X11', 'Linux', 'iPhone', 'iPad', 'Android'];
            const supportedOperatingSystems = ['Windows', 'MacOS', 'Unix', 'Linux', 'iOS', 'iOS', 'Android'];

            for (let i in patterns) {
                if (navigator.platform.indexOf(patterns[i]) !== -1) {
                    operatingSystem = supportedOperatingSystems[i];
                }
            }

            return operatingSystem;
        },

        /**
         * Reads the pure stylesheets and collects all the Chart styles before rendering
         *
         * @param {String} className
         * @return {object}
         */
        readStylesheetsByClassName: function(className) {
            let styles = document.styleSheets || new StyleSheetList();
            let localStyles = {};
            let classes;
            let currentStyle = null;

            for (let i = 0, styleNum = styles.length; i < styleNum; i++) {
                // Can't access external stylesheets
                if (!styles[i].href || styles[i].href.includes(location.hostname) === false) {
                    continue
                }

                classes = styles[i].cssRules || new CSSRuleList();

                for (let j = 0, ruleNum = classes.length; j < ruleNum; j ++) {
                    currentStyle = classes[j];

                    if (currentStyle instanceof CSSImportRule || currentStyle instanceof CSSMediaRule) {
                        continue;
                    }

                    if (classes[j].selectorText && classes[j].selectorText.includes('.'+className)) {
// console.log(classes[j])
                        let customDefinitions = [];
                        localStyles[classes[j].selectorText] = {};

                        for (let key in classes[j].style) {
                            if (classes[j].style.hasOwnProperty(key) && !isNaN(key)) {
                                customDefinitions.push(classes[j].style[key].replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); }));
                            }
                        }

                        for (let l = 0, definitionLength = customDefinitions.length; l < definitionLength; l++) {
                            localStyles[classes[j].selectorText][customDefinitions[l]] = classes[j].style[customDefinitions[l]];
                        }
                    }
                }
            }
            return localStyles;
        }
    };
};

window['Utility'] = Utility;

/***/ }),

/***/ 895:
/***/ (() => {

/**
 * A Bar Chart Element.
 *
 * @param {HTMLDivElement|Node} HTMLElement
 * @param {object} chartStyles
 * @return {*}
 */
const BarChartElement = function (HTMLElement, chartStyles)
{
    /** @instance Logger */
    let logger = new Logger('Bar Chart Element', 'MediumOrchid');
    /** @type {number} */
    const currentYear = (new Date()).getFullYear();
    /** @type {number} */
    const currentQuarter = Math.ceil(((new Date()).getMonth() + 1) / 4);

    const chartDataset = HTMLElement.querySelector('dl.chart-dataset');
    const rangeFrom = parseInt(chartDataset.dataset.rangefrom);
    const rangeTo = (new Date()).getFullYear()+1;
    const labels = chartDataset.querySelectorAll('dt');
    const bars = chartDataset.querySelectorAll('dd');

    let grid = '';
    let label = '';
    let style = '';

    for (let i = rangeTo; i >= rangeFrom; i--) {
        for (let j = 4; j > 0; j--) {
            label = j === 1 ? '<span>'+i+'</span>' : '';
            style = 'gridRow';

            if (j === 1) {
                style += ' year';
            }

            if (j === currentQuarter && i === currentYear) {
                style += ' thisQuarter';
            }

            grid += '<div class="'+style+'">'+label+'</div>';
        }
    }

    grid += '<div class="labels">';
    for (let index in labels) {
        if (labels.hasOwnProperty(index)) {
            let label = labels[index].innerText;
            grid += '<div>'+label+'</div>';
        }
    }
    grid += '</div>';

    for (let index in bars) {
        if (bars.hasOwnProperty(index)) {
            let bar = bars[index];
            let fromData = bar.dataset.from;
            let toData = bar.dataset.to;
            let skill = bar.dataset.skill;
            let counter = parseInt(index) + 1;

            let offsetBottom = getOffset(fromData, rangeFrom);
            let offsetTop = getOffset(toData, rangeFrom);

            grid += '<div class="skill '+skill+' col'+counter+'" style="bottom: '+offsetBottom+'px; height: '+(offsetTop-offsetBottom)+'px"></div>';
        }
    }

    /**
     * Counts the offset from the date info
     *
     * @param {string} dateInfo
     * @param {number} rangeFrom
     * @returns {number}
     */
    function getOffset(dateInfo, rangeFrom)
    {
        let startOffset = chartStyles['.BarChart .grid'].paddingBottom;

        if (startOffset.indexOf('px') !== -1)
            startOffset = parseInt(startOffset.replace(/px/, ''));
        else {
            startOffset = parseInt((parseFloat(startOffset.replace(/rem/, '')) * 10.0) + '');
        }

        let rowHeight = chartStyles['.BarChart .gridRow'].height;

        if (rowHeight.indexOf('px') !== -1)
            rowHeight = parseInt(rowHeight.replace(/px/, ''));
        else {
            rowHeight = parseInt((parseFloat(rowHeight.replace(/rem/, '')) * 10.0) + '');
        }

        if (dateInfo === 'today') {
            dateInfo = currentYear+'/Q'+currentQuarter;
        }

        const yearQuarter = dateInfo.split('/Q');
        const year = parseInt(yearQuarter[0]);
        const quarter = parseInt(yearQuarter[1]);
        // * 1 full year = 4 quarters, so the number of full years ((year - rangeFrom) * 4)
        // * new year = the 4th quarter finished, so it's already counted in full years, so a not full year (quarter - 1)
        // * The sum of full years and remaining quarters give the height of the bar: multiply with the height
        //   of a grid row and adds the bottom position
        return ((((year - rangeFrom) * 4) + (quarter - 1)) * rowHeight) + startOffset;
    }

    HTMLElement.innerHTML = grid;

    logger.componentElementInitSuccess(HTMLElement.id);

    return {
        /**
         * Returns the element ID.
         *
         * @returns {string}
         */
        getId: function () {
            return HTMLElement.id;
        },

        /**
         * Returns the element name.
         *
         * @returns {string}
         */
        getName: function() {
            return HTMLElement.id;
        },

        /**
         * Returns the HTML element
         *
         * @returns {HTMLDivElement|Node}
         */
        getHTMLElement: function () {
            return HTMLElement;
        },
    }
};

window['BarChartElement'] = BarChartElement;


/***/ }),

/***/ 986:
/***/ (() => {

/**
 * A Feature Toggle Switch element
 *
 * @param {HTMLDivElement|Node} HTMLElement
 * @param {String} featureName
 * @param {{state: boolean, label: string, storageKey: string}} toggleOptions
 * @returns {*}
 */
const FeatureToggleSwitchElement = function (HTMLElement, featureName, toggleOptions)
{
    /** @instance CookieStorage|DataStorage */
    let storage = globalThis.Components.get('dataStorage')
    /** @instance Logger */
    let logger = new Logger('Feature Toggle Switch Element', 'DarkOrange');
    // Wipe out any dirt
    HTMLElement.innerHTML = '';

    let state = storage.get(toggleOptions.storageKey) === 'On'
        ? true
        : toggleOptions.state;

    const checkbox = document.createElement('input');
    checkbox.setAttribute('type', 'checkbox');
    checkbox.setAttribute('id', HTMLElement.id + '-' + featureName);
    checkbox.checked = state;
    checkbox.addEventListener('change', function () {
        state = !HTMLElement.checked
        setState(state)
    });

    const label = document.createElement('label');
    label.setAttribute('for', HTMLElement.id + '-' + featureName);
    const labelText = document.createElement('span');
    labelText.innerHTML =  toggleOptions.label;
    const labelSwitch = document.createElement('span');
    label.appendChild(labelText);
    label.appendChild(labelSwitch);

    HTMLElement.appendChild(checkbox);
    HTMLElement.appendChild(label);

    /**
     *
     * @param {Boolean} state
     */
    const setState = function(state) {
        HTMLElement.checked = state;
        logger.actionTriggered('Set state', (state ? 'On' : 'Off'))
        storage.set(toggleOptions.storageKey, (state ? 'On' : 'Off'));

    };

    setState(state);

    logger.componentElementInitSuccess(HTMLElement.getAttribute('id'))

    return {
        /**
         * Returns the element ID.
         *
         * @returns {string}
         */
        getId: function () {
            return HTMLElement.id;
        },

        /**
         * Returns the feature name.
         *
         * @returns {String}
         */
        getName : function() {
            return featureName;
        },

        /**
         * Returns the HTML element
         *
         * @returns {HTMLDivElement|Node}
         */
        getHTMLElement: function () {
            return HTMLElement;
        },

        /**
         * Returns the current state.
         *
         * @returns {String}
         */
        getState : function () {
            return state ? 'on' : 'off';
        },

        /**
         * Toggles the switch on.
         */
        on : function() {
            setState(true);
        },

        /**
         * Toggles the switch off.
         */
        off : function () {
            setState(false);
        }
    }
};
window['FeatureToggleSwitchElement'] = FeatureToggleSwitchElement


/***/ }),

/***/ 997:
/***/ (() => {

/**
 * Lazy Load Image component.
 *
 * @returns {*}
 */
const LazyLoadImage = function ()
{
    /** @instance Utility */
    let utility = globalThis.Components.get('utility')
    /** @instance Logger */
    let logger = new Logger('Lazy Load Image', 'PowderBlue');
    /** @type {NodeList} */
    let lazyLoadImages;
    /** @type {number} */
    let idCounter = 1;
    /** @type {IntersectionObserver|IntersectionObserverFallback} */
    let imageObserver;

    let LazyLoadImageElements = [];

    if (!utility instanceof Utility) {
        throw new ReferenceError('This component requires the Utility component to be loaded.');
    }

    const IntersectionObserverFallback = function() {
        logger.actionFailed('the IntersectionObserver function is not supported. Loading images in normal mode.', '');

        return {
            observe: function (element) {
                element.src = element.dataset.src;
                logger.actionTriggered('An image element loaded', element.getAttribute('id'))
            }
        }
    };

    const intersectionObserverClass = typeof IntersectionObserver !== 'undefined'
        ? IntersectionObserver
        : IntersectionObserverFallback;

    /**
     * Finds a lazy-load image element by its ID.
     *
     * @param {string} id
     * @returns {*}
     */
    const getLazyLoadImageById = function(id)
    {
        for(let i = 0; i < LazyLoadImageElements.length; i++) {
            if(LazyLoadImageElements[i].getId() === id) {
                return LazyLoadImageElements[i];
            }
        }
    }

    /**
     * Initializes the loader and collects the elements.
     */
    const initialize = function()
    {
        logger.seekComponentElements();
        lazyLoadImages = document.querySelectorAll('img[data-src]');

        if (lazyLoadImages.length === 0) {
            logger.componentElementsNotFound();
            return;
        }

        imageObserver = new intersectionObserverClass((entries, imgObserver) => {
            entries.forEach((entry) => {
                if (entry.isIntersecting) {
                    /** @type LazyLoadImageElement lazyLoadImageElement */
                    let lazyLoadImageElement = getLazyLoadImageById(entry.target.id);
                    lazyLoadImageElement.loadImage();
                }
            })
        });

        lazyLoadImages.forEach(function (HTMLElement) {
            if (!HTMLElement.hasAttribute('id')) {
                HTMLElement.setAttribute('id', 'LazyLoadImage-' + (idCounter++));
            }

            LazyLoadImageElements.push(new LazyLoadImageElement(HTMLElement));
            imageObserver.observe(HTMLElement);
        });

        utility.triggerEvent(document, 'Component.LazyLoadImage.Ready', null, 1);
    };

    logger.componentLoaded();

    initialize();

    return {
        /**
         * Returns the collection of lazy-loaded images.
         *
         * @returns {*[]}
         */
        getLazyLoadImages: function () {
            return LazyLoadImageElements;
        },


        getLazyLoadImageById: function(id) {
            return getLazyLoadImageById(id);
        }
    };
};

window['LazyLoadImage'] = LazyLoadImage;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
const PRIVACY_ACCEPT_STORAGE_NAME = 'privacy_Accept_20251119';

__webpack_require__(491);
__webpack_require__(823);
__webpack_require__(559);
__webpack_require__(84);

__webpack_require__(768);
__webpack_require__(653);

__webpack_require__(986);
__webpack_require__(8);

__webpack_require__(73);
__webpack_require__(997);

__webpack_require__(326);
__webpack_require__(756);

__webpack_require__(895);
__webpack_require__(283);

__webpack_require__(192);
__webpack_require__(254);

__webpack_require__(322);

document.addEventListener('DOMContentLoaded', function () {
    globalThis.Components = new ComponentRepository();
    globalThis.Components.register('utility', new Utility());
    globalThis.Components.register('http', new Http());

    let dataStorage;
    try {
        dataStorage = new LocalStorage();
    } catch (e) {
        console.error(e);
        dataStorage = new CookieStorage();
        dataStorage.renew(PRIVACY_ACCEPT_STORAGE_NAME);
    }
    globalThis.Components.register('dataStorage', dataStorage);
    globalThis.Components.register('smoothScroll', new SmoothScroll());
    globalThis.Components.register('lazyLoadImage', new LazyLoadImage());
    globalThis.Components.register('barChart', new BarChart());
    globalThis.Components.register('collapsible', new Collapsible());

    const featureToggleOptions = {};

    globalThis.Components.register('featureToggle', new FeatureToggleSwitch(featureToggleOptions));

    Promise.allSettled(fetchAllDialogs()).then(function(response) {
        globalThis.Components.register('dialogWindow', new DialogWindow());
    });

    embedWorstPracticeSample();

    document.querySelectorAll('a.google').forEach(function (element) {
        element.addEventListener('click', function (event) {
            if (!confirm('This link will take you to a Google Service website.\nDo you really want it?')) {
                event.preventDefault();
                return false;
            }
        })
    })
});

/**
 * Open the dialog as soon as the Component is ready
 */
document.addEventListener('Component.DialogWindow.Ready', function() {
    const gdprDialog = globalThis.Components.get('dialogWindow').getDialogWindowElementByName('gdpr');

    if (gdprDialog) {
        gdprDialog.open();
        gdprDialog.getHTMLElement().addEventListener('Component.Dialog.Action.Save', function() {
            globalThis.Components.get('dataStorage').set('gdpr', 'On', false)
        });
        gdprDialog.getHTMLElement().addEventListener('Component.Dialog.Action.Close', function() {
            globalThis.Components.get('dataStorage').set('gdpr', 'On', false)
        });
    }
});

/**
 *Add smooth scroll function for content anchor link.
 */
document.addEventListener('Component.SmoothScroll.Ready', function() {
    const scrollToContentButton = document.querySelector('.m-menu__link.-downarrow');

    if (scrollToContentButton) {
        scrollToContentButton.addEventListener('click', function(event){
            event.preventDefault();

            globalThis.Components.get('smoothScroll').scrollToElementById('content', 10);
        });
    }
});

/**
 * Fetches all the dialog HTML data.
 *
 * @return {[]}
 */
const fetchAllDialogs = function() {
    let promises = [];
    const http = globalThis.Components.get('http');
    const dataStorage = globalThis.Components.get('dataStorage');
    const dialogDisplayOnceForLife = [
        'gdpr'
    ];

    const wrapperId = 'dialogWrapper_'+Math.ceil(Math.random()*1000000000);
    let dialogWrapper = document.getElementById(wrapperId);

    if (!dialogWrapper) {
        dialogWrapper = document.createElement('div');
        dialogWrapper.setAttribute('id', wrapperId);
        document.body.appendChild(dialogWrapper);
    }

    for (let i = 0, num = dialogDisplayOnceForLife.length; i < num; i++) {
        if (dataStorage.get(dialogDisplayOnceForLife[i]) !== 'On') {
            promises.push(http.fetch(
                '/dialogs/'+dialogDisplayOnceForLife[i]+'.html',
                'GET',
                true,
                'text/html',
                {},
                function (response) {
                    return response.text().then(function (data) {

                        dialogWrapper.innerHTML += data;

                        return new Promise((resolve, reject) => {
                            resolve('done');
                        });
                    });
                })
            );
        }
    }

    return promises;
};

/**
 * Embed a "Worst practice" code sample.
 */
const embedWorstPracticeSample = function () {
    const http = globalThis.Components.get('http');
    const badCodesCounter = 5;
    const badCodes = [];

    for (let i = 1; i <= badCodesCounter; i++) {
        let fileCounter = '' + i;
        badCodes.push(fileCounter.padStart(4, '0') + '.html');
    }

    const date = new Date();
    let day = date.getDate();
    if (day < 10) {
        day = '0' + day;
    }
    let month = (date.getMonth() + 1);
    if (month < 10) {
        month = '0' + month;
    }
    const year = date.getFullYear();
    const today = parseInt(year + '' + month + '' + day);
    const codeOfTheDay = today % badCodes.length;

    http.fetch(
        '/code-of-the-day/' + badCodes[codeOfTheDay],
        'GET',
        true,
        'text/html',
        {},
        function (response) {
            if (response.status !== 200) {
                console.warn('Looks like there was a problem. Status Code: ' + response.status);
                return;
            }

            // Examine the text in the response
            response.text().then(function (data) {
                document.querySelector('.codeOfTheDay__content').innerHTML = data;
                document.querySelector('input.codeOfTheDay__toggle').addEventListener('click', function (event) {
                    /** @type HTMLInputElement */
                    const element = event.target;
                    if (element.checked) {
                        document.body.style.overflow = 'hidden';
                        document.querySelector('.codeOfTheDay').style.zIndex = '101';
                    } else {
                        document.body.style.overflowY = 'auto';
                        document.body.style.overflowX = 'hidden';
                        document.querySelector('.codeOfTheDay').style.zIndex = '99';
                    }
                });
            });
        },
        null
    );
};
/******/ })()
;